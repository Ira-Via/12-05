# 12-05
12-05 «Индексы» Васяева Ирина
# Задание 1
Есть два варианта для решения данной задачи, где мы выясняем общий размер базы данных, размер, занимаемый индексами, и получаем процентное отношение общего размера всех индексов к общему размеру всех таблиц в учебной базе данных:
- Получаем общий размер базы данных
```
SELECT pg_size_pretty(pg_database_size(current_database())) AS total_database_size;
```
- Получаем размер, занимаемый индексами
```
SELECT pg_size_pretty(SUM(pg_total_relation_size(indexname))) AS total_index_size
FROM pg_indexes;
```
- Получаем процентное отношение общего размера всех индексов к общему размеру всех таблиц в учебной базе данных:
```
SELECT 
    (SUM(pg_total_relation_size(indexname))::decimal / NULLIF(SUM(pg_total_relation_size(table_name)), 0)) * 100 AS index_to_table_size_percentage
FROM 
    pg_indexes
JOIN 
    information_schema.tables ON tables.table_name = pg_indexes.tablename
WHERE 
    tables.table_schema = 'public';
```
# Задание 2
### 1: Выполнение `EXPLAIN ANALYZE`
```sql
EXPLAIN ANALYZE
SELECT DISTINCT CONCAT(c.last_name, ' ', c.first_name), SUM(p.amount) OVER (PARTITION BY c.customer_id, f.title)
FROM payment p
JOIN rental r ON p.payment_date = r.rental_date
JOIN customer c ON r.customer_id = c.customer_id
JOIN inventory i ON i.inventory_id = r.inventory_id
JOIN film f ON f.film_id = i.film_id
WHERE DATE(p.payment_date) = '2005-07-30';
```
### 2: Анализ результатов `EXPLAIN ANALYZE`
1. **Полное сканирование таблиц**: Если запрос выполняет полное сканирование таблиц (например, `payment`, `rental`), это может указывать на отсутствие индексов.
2. **Высокая стоимость операций**: Обратите внимание на стоимость операций (например, `Seq Scan`, `Hash Join`, `Nested Loop`), которые могут указывать на неэффективные способы соединения таблиц.
3. **Количество возвращаемых строк**: Если количество возвращаемых строк значительно превышает ожидаемое, это может указывать на необходимость более строгих условий фильтрации или индексов.
### 3: Оптимизация запроса
1. **Использование явных соединений**: Вместо использования старого синтаксиса `FROM table1, table2`, лучше использовать явные `JOIN` операторы. Это улучшает читаемость и может помочь оптимизатору.
2. **Добавление индексов**: Убедитесь, что у вас есть индексы на столбцах, которые используются в условиях соединения и фильтрации. Например:
   - Индекс на `payment(payment_date)`
   - Индекс на `rental(rental_date, customer_id, inventory_id)`
   - Индекс на `customer(customer_id)`
   - Индекс на `inventory(inventory_id, film_id)`
   - Индекс на `film(film_id)`
3. **Фильтрация данных**: Убедитесь, что фильтрация по дате выполняется на самом начале, чтобы уменьшить объем данных, обрабатываемых в последующих операциях.
4. **Избегание `DISTINCT`**: Если возможно, избегайте использования `DISTINCT`, так как это может быть дорогостоящей операцией. Если вы можете гарантировать уникальность строк, это улучшит производительность.
### Оптимизированный запрос
```sql
SELECT CONCAT(c.last_name, ' ', c.first_name) AS full_name, 
       SUM(p.amount) OVER (PARTITION BY c.customer_id, f.title) AS total_amount
FROM payment p
JOIN rental r ON p.payment_date = r.rental_date
JOIN customer c ON r.customer_id = c.customer_id
JOIN inventory i ON i.inventory_id = r.inventory_id
JOIN film f ON f.film_id = i.film_id
WHERE p.payment_date = '2005-07-30' -- Убираем DATE() для повышения производительности
GROUP BY c.customer_id, f.title, c.last_name, c.first_name;
```
### Пояснение по вопросу эксперта:  
Чтобы определить ожидаемое количество возвращаемых строк в результате SQL-запроса, можно воспользоваться различными подходами и инструментами, которые помогут провести анализ и оценку. Вот несколько методов, которые можно использовать для этой цели:  
1. Использование команды EXPLAIN
```
EXPLAIN SELECT ...
```
- rows: ожидаемое количество строк, которые будут возвращены на каждом этапе обработки.
- cost: оценка затрат на выполнение этого шага.
2. Анализ статистики таблиц
- pg_class: содержит информацию о таблицах и индексах, включая текущие оценки количества строк.
- pg_stats: может предоставить информацию о распределении данных в столбцах, что поможет в понимании, каких значений следует ожидать.
Пример:
```
SELECT relname, n_live_tup 
FROM pg_stat_user_tables 
WHERE relname = 'your_table_name';
```
3. Оценка на основе ограничений и фильтров
Пример:
```
SELECT COUNT(*)
FROM your_table
WHERE your_condition;
```
4. Инструменты оптимизации
# Задание 3*
В PostgreSQL существует несколько типов индексов, которые обеспечивают гибкость и мощные возможности для оптимизации запросов. Некоторые из этих индексов уникальны для PostgreSQL и не имеют прямых аналогов в MySQL. Вот основные типы индексов, используемые в PostgreSQL, которые отсутствуют в MySQL:

1. **B-tree индексы**: Это наиболее распространенный тип индекса, который используется по умолчанию. Он поддерживает операции равенства и диапазона, и его можно использовать для сортировки. Хотя B-tree индексы есть и в MySQL, их реализация и возможности могут различаться.

2. **Hash индексы**: Эти индексы оптимизированы для операций равенства. В PostgreSQL они могут быть полезны для оптимизации запросов, где используются операции `=`. MySQL также поддерживает хеш-индексы, но они имеют ограничения и не так часто используются.

3. **GiST (Generalized Search Tree) индексы**: Этот тип индекса позволяет создавать индексы для более сложных типов данных, таких как геометрические данные и полнотекстовые поисковые запросы. GiST индексы обеспечивают возможность создания пользовательских типов индексов, что делает их очень мощными. MySQL не имеет аналогичных индексов.

4. **GIN (Generalized Inverted Index) индексы**: GIN индексы особенно полезны для работы с массивами и полнотекстовыми поисковыми запросами. Они позволяют эффективно индексировать данные, которые могут содержать несколько значений, такие как массивы или JSONB. MySQL не имеет GIN индексов.

5. **SP-GiST (Space-partitioned Generalized Search Tree) индексы**: Этот тип индекса подходит для работы с данными, которые имеют пространственные или иерархические структуры. SP-GiST индексы могут использоваться для оптимизации запросов на основе пространственных данных, чего MySQL не поддерживает так же эффективно.

6. **BRIN (Block Range INdexes) индексы**: BRIN индексы предназначены для работы с очень большими таблицами, где данные имеют физическую последовательность. Они хранят минимальные и максимальные значения для блоков данных, что позволяет быстро находить нужные строки. MySQL не имеет аналогичных индексов.

7. **Пользовательские индексы**: PostgreSQL позволяет создавать пользовательские индексы, используя расширения и специфические функции, что дает разработчикам возможность оптимизировать запросы под свои нужды. MySQL имеет более ограниченные возможности для создания пользовательских индексов.
